<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>core.gc</title>
        </head><body>
        <h1>core.gc</h1>
        <!-- Generated by Ddoc from core\gc.d -->

<dl><dt><big><a name="GC"></a>class <u>GC</u>;
</big></dt>
<dd>This is the core of the <u>GC</u>.<br><br>

<dl><dt><big><a name="GC.pinAllocation"></a>void <u>pinAllocation</u>(void* <i>allocation</i>);
</big></dt>
<dd>Ensure that an allocation will not be moved by a compacting
 allocator during a collection.
<br><br>
For each invocation of this method referencing the same
 allocation, a call to <span class="crossreference" style="color: blue"><u>unpinAllocation</u></span> must be
 performed in order to allow the underlying allocator to <span class="gc_clarify" style="background: #DDDDDD">once
 again move the allocation</span>.

<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>allocation</i></td>
<td>A potentially interior pointer to the allocation to pin.</td></tr>
</table><br>
<b>Note:</b><br>
This will not prevent an allocation from being collected;
 for that use <span class="crossreference" style="color: blue"><u>addRoot</u></span>.
 This also will not prevent it from being copied by a call
 to <span class="gc_todo" style="background: #FFFF00">realloc/extend</span>, <span class="gc_clarify" style="background: #DDDDDD">as it is assumed that the caller
 of those methods will update whatever references to the
 allocation are required</span>.

<br><br>
<b>Errors:</b><br>
<div class="gc_error">It is an error to call this with a pointer to
 memory that was either not allocated by the GC,
 or else was already freed by the GC.</div>
 <div class="gc_error">It is an error for a pinned allocation which is
 not a root to have no living references.</div><br><br>

</dd>
<dt><big><a name="GC.unpinAllocation"></a>void <u>unpinAllocation</u>(void* <i>allocation</i>);
</big></dt>
<dd>Provided that this method has been called once for every call
 to <span class="crossreference" style="color: blue"><u>pinAllocation</u></span> referencing the same allocation, <span class="gc_clarify" style="background: #DDDDDD">this
 will tell a compacting allocator that it is allowed to move the
 allocation again</span>.
<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>allocation</i></td>
<td>A potentially interior pointer to the allocation to unpin.</td></tr>
</table><br>
<b>Errors:</b><br>
<div class="gc_error">It is an error to call this with a pointer to
 memory that was either not allocated by the GC, or else
 was already freed by the GC.</div><br><br>

</dd>
<dt><big><a name="GC.ignoreThread"></a>void <u>ignoreThread</u>(tid_t <i>threadID</i>);
</big></dt>
<dd>This method tells the GC to neither stop, nor scan the
 specified thread during a collection.
<br><br>
An example of a thread that would be suitable to being
 marked as not scanned would be an external thread that
 does only manual memory management, never allocating
 through the GC, and will neither access or modify any
 allocations created through the GC that have not been
 added as roots.

<br><br>
<b>Params:</b><br>
<table><tr><td>tid_t <i>threadID</i></td>
<td>The ID of the thread to ignore when performing a collection.</td></tr>
</table><br>
<b>Implementation Details:</b><br>
<div class="gc_impl_detail" style="background: #00A0FF">This will be one of the instances
 of dynamic code-gen with a fallback for unsupported platforms.
 Due to the fact there should only be a small number of threads
 being ignored by the GC, we will statically expand all thread
 IDs into pairs of cmp &amp; setne instructions, as this will eliminate
 all possible cases where the CPU could mispredict a branch or
 even a return when checking to see if a thread is ignored.</div><br><br>

</dd>
<dt><big><a name="GC.markAsReferenced"></a>void <u>markAsReferenced</u>(void* <i>allocation</i>);
</big></dt>
<dd>This method determines which allocator, if any owns <i>allocation</i>,
 and will invoke that allocator's <span class="crossreference" style="color: blue"><u><u>markAsReferenced</u></u></span> method,
 passing <i>allocation</i> as-is.
<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>allocation</i></td>
<td>A potentially interior pointer to a potential GC <i>allocation</i>.</td></tr>
</table><br>
<b>Errors:</b><br>
<div class="gc_error">It is an error to call this method with a <b>null</b> <i>allocation</i>.</div><br><br>

</dd>
<dt><big><a name="GC.finalize"></a>bool <u>finalize</u>(void* <i>allocation</i>, immutable TypeInfo <i>typeInfo</i>);
</big></dt>
<dd>This will check to see if an allocation needs to be
 finalized, and if it does, add it to the finalization
 pool.
<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>allocation</i></td>
<td>The allocation to potentially <u>finalize</u>.</td></tr>
<tr><td>TypeInfo <i>typeInfo</i></td>
<td>The <span class="crossreference" style="color: blue"><u>TypeInfo</u></span> representing the type
            of <i>allocation</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
If <b>true</b>, then <i>allocation</i> has no finalizer to call. This means
 that the allocator that called this is allowed to immediately
 free the memory used by this <i>allocation</i>.
<br><br>

 If <b>false</b>, then the allocator that calls this must not mark
 the memory used by <i>allocation</i> as free, and instead must ensure
 that <i>allocation</i> is not freed. It must also ensure that <i>allocation</i>
 is only ever passed to this method once, otherwise multi-finalization
 will occur.<br><br>

</dd>
<dt><big><a name="GC.markAsFinalized"></a>void <u>markAsFinalized</u>(void* <i>allocation</i>);
</big></dt>
<dd>This will determine which allocator, if any, owns <i>allocation</i>
 and invokes that allocator's <span class="crossreference" style="color: blue"><u><u>markAsFinalized</u></u></span> method
 passing <i>allocation</i> as-is.
<br><br>
<b>Notes:</b><br>
This method <b><u>MUST NOT</u></b> be called from user code,
 nor should it be called by the GC; instead it is to only
 be called by the prologue generated for finalizers.

<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>allocation</i></td>
<td>The potentially GC-owned allocation to mark
              as finalized.</td></tr>
</table><br>
<b>TODO:</b><br>
My original design had this return a bool for successfull
 marking as finalized; Why?<br><br>

</dd>
<dt><big><a name="GC.releaseAllocator"></a>void <u>releaseAllocator</u>(Allocator* <i>allocator</i>);
</big></dt>
<dd>Release the page of memory allocated to a GC allocator.
<br><br>
The allocator being released is responsible for ensuring
 that all allocations it owns have been properly finalized
 and are indeed free before passing itself to this. It is
 not guaranteed that the memory owned by the allocator will
 be immediately freed, it may be cached for later use.

<br><br>
<b>TODO:</b><br>
This method may need to go away<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
